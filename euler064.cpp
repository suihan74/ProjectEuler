/**
 * Problem 64 「奇数周期の平方根」
 * 平方根は連分数の形で表したときに周期的であり, 以下の形で書ける:
 *
 * √N = a0 + 1 / (a1 + 1 / (a2 + 1 / (a3 + ...)))
 *
 * 例えば, √23を考えよう.
 *
 * √23 = 4 + √23 - 4 = 4 + 1 / (1 / (√23 - 4)) = 4 + 1 / (1 + (√23 - 3) / 7)
 *
 * となる.
 *
 * この操作を続けていくと,
 *
 * √23 = 4 + 1 / (1 + 1 / (3 + 1 / (1 + 1 / (8 + ...))))
 *
 * を得る.
 *
 * 操作を纏めると以下になる:
 *
 * a0 = 4, 1/(√23-4) = (√23+4)/7 = 1 + (√23-3)/7
 * a1 = 1, 7/(√23-3) = 7(√23+3)/14 = 3 + (√23-3)/2
 * a2 = 3, 2/(√23-3) = 2(√23+3)/14 = 1 + (√23-4)/7
 * a3 = 1, 7/(√23-4) = 7(√23+4)/7 = 8 + (√23-4)
 * a4 = 8, 1/(√23-4) = (√23+4)/7 = 1 + (√23-3)/7
 * a5 = 1, 7/(√23-3) = 7(√23+3)/14 = 3 + (√23-3)/2
 * a6 = 3, 2/(√23-3) = 2(√23+3)/14 = 1 + (√23-4)/7
 * a7 = 1, 7/(√23-4) = 7(√23+4)/7 = 8 + (√23-4)
 * よって, この操作は繰り返しになることが分かる. 表記を簡潔にするために, √23 = [4;(1,3,1,8)]と表す. (1,3,1,8)のブロックは無限に繰り返される項を表している.
 *
 * 最初の10個の無理数である平方根を連分数で表すと以下になる.
 *
 * √2=[1;(2)], period=1
 * √3=[1;(1,2)], period=2
 * √5=[2;(4)], period=1
 * √6=[2;(2,4)], period=2
 * √7=[2;(1,1,1,4)], period=4
 * √8=[2;(1,4)], period=2
 * √10=[3;(6)], period=1
 * √11=[3;(3,6)], period=2
 * √12= [3;(2,6)], period=2
 * √13=[3;(1,1,1,1,6)], period=5
 * N ≤ 13で奇数の周期をもつ平方根は丁度4つある.
 *
 * N ≤ 10000 について奇数の周期をもつ平方根が何個あるか答えよ.
*/

#include <cmath>
#include <cstdint>
#include <iostream>
#include <vector>

// is_int関数を使うため
#include "polygonal_number.h"

using uInt = std::uint_fast32_t;
using Euler::is_int;

int main(void)
{
  uInt count = 0;
  for (uInt n = 2; n <= 10000; n++) {
    const auto rt_n = std::sqrt(n);
    if (is_int<double, uInt>(rt_n)) { continue; }

    // a_1, a_2, ... を格納するためのベクタ
    // 繰り返す部分だけが欲しいので，今回a_0は無視する
    std::vector<uInt> a_vec;
    // a_0のときだけ特殊化
    // a_0, (sqrt(N) - b) / c;  b == a, c == 1
    uInt a = rt_n;
    uInt b = a;
    uInt c = 1;

    // 説明より，a_1から繰り返すことは確定しているっぽいので，
    // a_1とともに生成される連分数のパーツを記録しておく
    uInt b_1 = 0;
    uInt c_1 = 0;
    for (;;) {
      // abcの計算順は変えちゃ駄目
      c = (n - b * b) / c;
      a = (rt_n + b) / c;
      b = a * c - b;
      if (c_1 == 0) {  // a_1の時の分数のパーツを記録
        b_1 = b;
        c_1 = c;
      }
      else if (b == b_1 && c == c_1) { // ループ点発見
        break;
      }
      a_vec.push_back(a);
    }

    if (a_vec.size() % 2) {
      count++;
    }
  }
  std::cout << "Euler064: " << count << std::endl;
  return 0;
}
